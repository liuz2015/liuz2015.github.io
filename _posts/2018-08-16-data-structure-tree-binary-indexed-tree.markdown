---
layout:     post
title:      "搞懂树状数组"
subtitle:   "一种很有趣的数据结构"
date:       2018-08-16
author:     "Liuz2015"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - 数据结构
    - 树
    - 数组
    - 树状数组
---

## 目录
- [简介](#简介)
- [结构](#结构)
- [实现原理](#实现原理)
- [修改](#修改)
- [查询](#查询)
- [总结](#总结)
- [参考资料](#参考资料)

## 简介

平常我们会遇到一些对数组进行维护查询的操作，比较常见的如：修改某点的值、求某个区间的和。对于普通数组而言，修改某点的值是非常容易的，复杂度是O(1)；但是对于求一个区间的和就要扫一遍了，复杂度是O(N)。而如果要对数组进行M次求和，复杂度就是O(M*N)，那么有没有快一点的实现方式呢？

这里我们就隆重请出今天的主角——树状数组。树状数组(Binary Indexed Tree(B.I.T), Fenwick Tree)是一个**查询和修改复杂度都为log(n)的数据结构**。主要用于查询任意两位之间的所有元素之和，但是每次只能修改一个元素的值；经过简单修改可以在log(n)的复杂度下进行范围修改，但是这时只能查询其中一个元素的值(如果加入多个辅助数组则可以实现区间修改与区间查询)。

## 结构

树状数组是什么样的呢？先看两幅图，下面的说明都是基于这两幅图的，上边的叫A图吧，下边的叫B图：

![A图](/img\in-post\data-structure-bit\bit-a.png)

![B图](/img\in-post\data-structure-bit\bit-b.png)

是不是很像一颗树？对，这就是为什么叫树状数组。

先看A图，a数组就是我们要维护和查询的数组，也就是原来的普通数组，但是其实我们整个过程中根本用不到a数组，图上画出来主要是便于我们理解。c数组才是我们全程关心和操纵的重心，我们可以利用它来进行求和，而读取某位置的数据其实就是这个位置的和减去前一个位置的和就好了，因此不需要a数组（节省空间）。

先由图来看看c数组的规则，其中c4 = c2+c3+a3，c6 = c5+a6，c8 = c4+c6+c7+a8...有同学会问了：哇，这个数组还要这样去计算，那不麻烦死了？先不必纠结怎么做到的，我们只要知道c数组的大致规则即可，很容易知道c8表示a1～a8的和，但是c6却是表示a5～a6的和，为什么会产生这样的区别的呢？或者说发明她的人为什么这样区别对待呢？答案是，这样会使操作更简单！

看到这相信有些人就有些感觉了，为什么复杂度被lg了呢？可以看到，c8可以看作a1～a8的左半边和+右半边和，而其中左半边和是确定的c4，右半边其实也是同样的规则把a5～a8一分为二...继续下去都是一分为二直到不能分，可以看看B图。怎么样？是不是有点二分的味道了？

更关键的是我们可以使用一个巧妙的方法去实现它。

## 实现原理

说这个之前我先说个叫lowbit的东西，lowbit(k)就是把k的二进制的高位1全部清空，只留下最低位的1,比如10的二进制是1010,则lowbit(k)=lowbit(1010)=0010(2进制)，介于这个lowbit在下面会经常用到，这里给一个非常方便的实现方式，比较普遍的方法lowbit(k)=k&-k，这是位运算，我们知道一个数加一个负号是把这个数的二进制取反+1，如-10的二进制就是-1010=0101+1=0110，然后用1010&0110，答案就是0010了！明白了求解lowbit的方法就可以了，继续下面。

lowbit代码如下：

```cpp
int lowbit(int k)
{
	return k&-k;
}
```

上面那么多文字说lowbit，还没说它的用处呢，它就是为了联系a数组和c数组的！ck表示从ak开始往左连续求lowbit(k)个数的和，比如c[0110]=a[0110]+a[0101]，就是从110开始计算了0010个数的和，因为lowbit(0110)=0010，可以看到其实只有低位的1起作用，因为很显然可以写出c[0010]=a[0010]+a[0001]，这就为什么我们任何数都只关心它的lowbit，因为高位不起作用（基于我们的二分规则它必须如此！），除非除了高位其余位都是0，这时本身就是lowbit。

## 修改

既然关系建立好了，看看如何实现a某一个位置数据更改的，a数组本身不会直接改的（开始就说了，a根本不存在），实际上是维护c数组应有的性质，因为后面求和要用到。而维护也很简单，比如更改了a[0011]，我们接着要修改c[0011],c[0100],c[1000]，这是很容易从图上看出来的，但是你可能会问，他们之间有申明必然联系吗？每次求解总不能总要拿图来看吧？其实从0011——>0100——>1000的变化，视觉上来看，就是把**尾部的连续的1全部都去掉并换到更高位的1**，记住每次变换都要有一个高位的1产生，对于1011，就是把最后面连续的1都去掉，变成1000了，然后在换成一个高位的1，变成1100；这时候，有聪明的同学就发现了，其实这个操作是对最低位的1加一个1，对于刚才的1011来说，就是加上一个0001，如果对于1010来说，就是加上0010就好了；这时候，我们前面介绍的lowbit就用上了，刚才的操作可以借助lowbit进行：k += lowbit(k)。

好吧，现在更新的次序都有了，可能又会产生新的疑问了：为什么它非要是这种关系啊？这就要追究到之前我们说c8可以看作a1～a8的左半边和+右半边和的内容了，为什么c[0011]会影响到c[0100]而不会影响到c[0101]，这就是之前说的c[0100]的求解实际上是这样分段的区间 c[0001]~c[0001] 和区间c[0011]~c[0011]的和，数字太小，可能这样不太理解，在比如c[0100]会影响c[1000]，为什么呢？因为c[1000]可以看作0001～0100的和加上0101~1000的和，但是0101位置的数变化并会直接作用于c[1000]，因为它的尾部1不能一下在跳两级在产生两次高位1,是通过c[0110]间接影响的，但是，c[0100]却可以跳一级产生一次高位1。

可能上面说的你比较绕了，那么此时你只需注意：c的构成性质（其实是分组性质）决定了c[0011]只会直接影响c[0100]，而c[0100]只会直接影响[1000]，而下表之间的关系恰好是也必须是k +=lowbit(k)。此时我们就是写出更新维护树的代码：

```cpp
void write(int k, int num)//将ck的值改为num
{
	while (k < MAX)
	{
		c[k] += num;
		k += lowbit(k);
	}
}

```

## 查询

当我们要查询具体某一个点的值时，实就是这个位置的和减去前一个位置的和就好了，因此我们关注求和即可。

有了上面的基础，说求和就比较简单了。比如求0001～0110的和就直接c[0100]+c[0110]，分析方法与上面的恰好逆过来，而且写法也是逆过来的，具体就不赘述了：

```cpp
int read(int k)//1~k的区间和  
{
     int sum = 0;
     while (k > 0)
     {
         sum += c[k];
         k -= lowbit(k);
     }
     return sum;
}
```

## 总结

首先，明白树状数组所白了是按照二分对数组进行分组；维护和查询都是O(lgn)的复杂度，复杂度取决于最坏的情况，也是O(lgn);lowbit这里只是一个技巧，关键在于明白c数组的构成规律;分析的过程二进制一定要深入人心，当作心目中的十进制。

## 参考资料
- [树状数组_百度百科](https://baike.baidu.com/item/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/313739?fr=aladdin)

