---
layout:     post
title:      "搞懂迪杰斯特拉算法"
subtitle:   "如何解决最短路径问题"
date:       2018-08-24
author:     "Liuz2015"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - 算法
    - 图
    - 最短路径
    - 迪杰斯特拉算法
---

## 目录
- [简介](#简介)
- [算法实现](#算法实现)
- [算法性能](#算法性能)
- [扩展](#扩展)
- [参考资料](#参考资料)

## 简介

迪杰斯特拉（Dijkstra）算法是由荷兰计算机科学家狄克斯特拉于1959年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。

迪杰斯特拉算法要求有向图中不存在负权边，如果图中存在负权边，则需要使用Bellman-Ford算法。

## 算法实现

有向图G=(V, E)，V表示图的所有顶点的集合，E为图的所有边的集合，源点记为s；我们需要维护一个顶点集合S，使得源点s到集合S中的顶点的最短路径的权值均已确定；同时使用一个最小优先队列Q来保存待访问的顶点，队列排序的关键字是s到该顶点的路径的权值。

1. 遍历V的所有顶点，将顶点放入Q中，将s的路径权值设为0，其余顶点的的路径权值设为无穷大。
2. 从Q中取出路径权值最小的顶点u，需要保证u在V中，且不在S中。
3. 访问顶点v，遍历v关联的且不在S中的所有顶点，如果顶点不在Q中，则将顶点直接放入Q中；如果顶点在Q中，我们需要对顶点进行**松弛**操作。
4. 松弛操作是指：源点s到顶点v的路径权值为d1，源点s到w的路径权值为d2，顶点v到w的路径权值为d3，如果d1+d3<d2，则将源点s到w的路径权值更新为d1+d3，并将其更新到Q中。
5. 重复步骤2到4，直到Q为空。

代码如下，对集合S做了修改，使用一个数组保存s到其余顶点的距离，有向图G的相关类型需要具体实现（*代码参考《算法（第四版）》*）：

```java
public class DijkstraSP {
    private double distTo[];// 保存权重，最短路径的总权重，distTo[w]表示s到w最短路径的总权重
    private DirectedEdge edgeTo[];// 最短路径的边
    private IndexMinPQ<Double> pq;// 最小优先队列

    public DijkstraSP(EdgeWeightedDigraph G, int s) {
        distTo = new double[G.V()];
        edgeTo = new DirectedEdge[G.V()];
        //步骤1
        pq = new IndexMinPQ<Double>(G.V());
        for (int i = 0; i < distTo.length; i++) {
            distTo[i] = Double.POSITIVE_INFINITY;
        }
        distTo[s] = 0.0;
        pq.insert(s, 0.0);
        while (!pq.isEmpty()) {
            relax(G, pq.delMin());
        }
    }
    private void relax(EdgeWeightedDigraph G, int v) {
        for (DirectedEdge e : G.adj(v)) {
            int w = e.to();
            if (distTo[w] > distTo[v] + e.weight()) {
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
                if (pq.contains(w))
                    pq.changeKey(w, distTo[w]);
                else
                    pq.insert(w, distTo[w]);
            }
        }
    }
}
```

在一些迪杰斯特拉的实现流程中，没有使用最小优先队列来处理下一个要访问的顶点，而是需要去遍历一遍存有s到v路径权值的顶点集合，这里的时间消耗为O(n)，这使得整个算法的时间消耗为O(n<sup>2</sup>)，通过使用最小优先队列，可以使得获取下个访问顶点v的操作时间变为O(1)，假设最小优先队列使用最小堆这样的结构来实现的话，那么将待访问节点放入

## 算法性能

迪杰斯特拉算法的性能会受最小优先队列实现方式的影响。

在这里我们假设使用**最小堆**作为最小优先队列的实现方式，基于最小堆的最小优先队列各操作的运行时间在下文中直接给出，不清楚的读者自行查阅资料。

首先看步骤1，需要遍历所有顶点，运行时间为V；

再看步骤2、3、4，这是一个循环过程，循环的总次数为队列的长度，也就是顶点个数，记为V；

在步骤2中，我们要从最小优先队列中取出权值最小的顶点作为下个访问顶点，该操作时间为O(lgV)；

在步骤3中，我们要遍历该顶点的所有的边，在有向图G中，边的总数为E，而一条边不可能被遍历两次，因此，在队列的整个循环中，边被遍历的总次数是E，我们把一次循环遍历的次数记为E/V，方便后面计算；

在步骤4中，松弛操作要求我们每次都要将新的路径权值更新或者插入到队列中，这个操作时间为O(lgV)（顶点个个数V也是队列长度）；

步骤3中会循环进行步骤4，因此步骤3、4的总运行时间为O(ElgV/v)；

再加上步骤2的时间，一次循环中步骤2、3、4的运行时间为O((1+E/V)lgV)，考虑队列的循环次数为V，则运行时间为O((V+E)lgV)；

因此当使用最小堆作为最小优先队列的实现方式时，迪杰斯特拉算法的运行时间为O((V+E)lgV)。

而在一些实现中，队列可能直接使用普通数组来实现，这时候，队列的插入或更新操作运行时间都为O(1)；但是，队列的取最小值操作运行时间为O(V)，因此算法的运行时间就变为O(V<sup>2</sup>+E)。

## 扩展

松弛操作是在最短路径算法中很重要的一个操作，除了迪杰斯特拉算法，这个操作也被应用在其他算法中，如前面提到的Bellman-Ford算法。

迪杰斯特拉算法的缺陷就是无法处理存在负权值的边，因为当我们把一个顶点加入到集合S中，我们就确定这就是最短路径了，如果边的权值存在负数，那么在集合S中存储的顶点的路径权值就不一定是最小的，也就不是最短路径了。对于存在负权值边的图，我们需要使用Bellman-Ford算法进行处理。

迪杰斯特拉算法的实现思想其实和最小生成树的Prim算法的实现思想很相似。最小生成树中，我们需要使得整棵树的边的权值最小，于是每一步都向这棵树中加一条**权值最小**的边；而在最短路径问题中，我们则是在每一步都加一条**路径权值最小**的边。

## 参考资料
- 《算法导论》
- 《算法》
- [迪杰斯特拉算法_百度百科](https://baike.baidu.com/item/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/4049057?fr=aladdin)