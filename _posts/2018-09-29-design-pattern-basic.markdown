---
layout:     post
title:      "设计模式概览"
subtitle:   ""
date:       2018-09-29
author:     "Liuz2015"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - 设计模式
---


## 目录
- [简介](#简介)
- [设计原则](#设计原则)
- [设计模式概览](#设计模式概览)
- [参考资料](#参考资料)

## 简介

设计模式可以看做是计算机编程的方法和经验，因为这些经验是有用、通用的，并且经过反复检验和改进的，因此可以把他们称为“模式”。使用设计模式，不仅可以使得代码更加可靠、健壮，同时也能提高代码的可理解性。

常常被使用的，大家很熟悉的设计模式有：工厂模式、单例模式、策略模式、责任链模式、适配器模式等等，在许多工程（Java工具类、Spring等）源码中都可以看到他们的应用。

本文对经典的23种设计模式进行了简要概述，对于其中几种重要的设计模式，可以阅读我写的其他几篇设计模式相关文章，从而有更深入的理解。

此外，github上有一个使用Java编码的设计模式项目，对许多设计模式都进行了实现，项目地址：https://github.com/iluwatar/java-design-patterns

## 设计原则
一、找出变与不变部分，将变化部分分离出来并封装，更易扩展。

二、针对接口编程，接口是指对象的接口(方法)，接口具体实现独立出来，对象内部主要关注接口。

三、多用组合，少用继承，组合更加灵活。

四、松耦合，减少对象之间的相互依赖。

五、开闭原则，开放扩展，关闭修改。

六、最少知识原则（迪米特法则），类间解耦，弱耦合。

七、好莱坞原则，由高层调用低层。

八、单一责任原则，每个类实现自己主要责任，其他责任由其他类实现后再组合。

## 设计模式概览

### 创建型
#### 工厂模式
将对象的创建分离出来，并且能够延迟到子类中实现。

#### 抽象工厂
将工厂类抽像，提供接口，具体实现放到工厂子类中实现，对应产品族的概念。

#### 单例模式
在整个程序中只有一个对象，要注意多线程情形。饥饿式/懒惰式，保证线程安全。

#### 建造模式
将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。创建过程分步骤来。并且可以将该对象本身的构造方法隐藏起来。

应用场景：一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。 

#### 原型模式
用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。

应用场景：用new创建一个对象需要非常繁琐的数据准备或者权限。

### 行为型
#### 策略模式StrategyPattern
定义算法族(一组行为)，分别封装，分离出算法的变化，使得它们可以相互替换。

#### 状态机模式
对象持有多个状态类实例，状态改变时可以改变行为，状态的改变被封装起来。与策略模式不同，策略模式下，客户需要知道这些策略（实现的算法），然后选择策略，而状态机只是去切换状态，不用了解具体的行为实现。

#### 模板方法模式
将算法复用部分提取出来并在超类中实现，特殊化部分在子类中实现，超类中完成算法的调用。在自己的netty模块中 处理不同方法的请求时使用了该模式。

#### 迭代器模式
针对某个类扩展iterator接口，在其中实现遍历，隐藏该类中集合的实现。

#### 命令模式
将对目标对象的调用分离并实现，即是命令，用户只需调用命令，从而与目标对象解藕。有命令请求者，命令，命令执行者，装配者四个角色。命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。

#### 观察者模式ObserverPattern
将观察者注册到主题上，建立主题与观察者之间的一对多依赖，主题可以通知观察者进行更新。

#### 职责链模式Chain of Responsibility
使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系， 将这个对象连成一条链，请求会沿着这条链传递该请求，直到有一个对象处理这个请求为止。比如：Servlet Filter。

#### 中介者模式Mediator
用一个中介对象封装一些列的对象交互，避免这些对象之间的耦合，对象只用注重自身的实现，而他们之间的互动则都在中介者里面去处理。

#### 访问者模式Visitor
表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。 

#### 解释器模式Interpreter
给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。比如加减乘除这样的算式。有抽象解释器（interpret()方法）、实现了interpret的终结符（某个数字）表达式以及非终结符（加号）表达式，当然，还需要一个容器来存放终结符的信息。该模式使用起来很麻烦，因为会引起效率、性能以及维护等问题。

#### 备忘录模式Memento
在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。客户端要对对象O进行操作前，先获取对象O的一个状态A，客户端在操作后，通过将状态A传回对象O，就可以使对象O恢复操作前的状态。这个状态就是一个“备忘录”（Memento），此外还有发起人（Originator）：要被备份的成员。管理角色（Caretaker）：用于管理备忘录对象的实现类。应用比如undo或者rollback。

### 结构型
#### 装饰器模式Decorator Pattern
创建了一个装饰类，用来包装原有的类，提供了额外的功能，扩展/继承自该对象是为了类型匹配。比如：JAVA IO。

#### 适配器模式Adapter
为了满足C类的使用需求（C类需要使用A类，但是A类的功能不够用，需要使用B类的功能），此时需要创造一个适配器继承目标A类，但在内部实现上使用B类，也就是把B类进行包装，此时C类就可以使用这个适配器来达到目的，即是改变类的类型和接口来适配需求。

#### 代理模式
与一个对象继承相同接口，并对该对象进行包装，提供给外界使用。装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话 说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

#### 组合模式
将对象组合成为树形结构，来表现整体/部分的结构层次，对象类型相同，层次不同。最典型的就是文件系统结构，抽象类File，文件夹FileFolder继承自File同时内部可以存储File集合，TextFile，ImageFile也继承自File可放在文件夹中，同时文件夹本身也可以放在文件夹中。好处就是用户对单个对象/组合对象的操作使用具有一致性。

#### 外观模式
完成一个任务时，要调用多个类的接口，用一个类包装好它们，从而简化接口。减少客户端与这多个类的直接交互，同时方便了对多个类的接口的管理。

#### 桥模式Bridge
将抽象部分与它的实现部分相分离，使他们可以独立的变化。简单来说，就是当一个对象可能会有多维度的变化时（比如一条消息，其发送方式可能有短信/邮件等，其紧急程度又分为普通/加急等），就可以利用桥梁模式来进行组合（使用了类的组合），从而避免使用类继承带来的类数量/关系过于复杂的问题。 

#### 享元模式Flyweight
当客户端要使用很多的对象，而这些对象实例是可以重复使用的，就可以使用该模式。该模式提供方法使得客户端可以分享这些对象实例，从而减少运行开销（不需要保存过多的对象也不需要创建很多次对象）。包含了工厂模式/单例模式的思想，使用map类容器来存储工厂生产的唯一对象实例，当客户端要获取该对象时，存在实例就返回不存在则新建。比如Java中的String对象就是这样处理的。String a = “hello”;String b = "hello";return a==b;返回是true。

## 参考资料
- 《Head First设计模式》
- 《设计模式》

