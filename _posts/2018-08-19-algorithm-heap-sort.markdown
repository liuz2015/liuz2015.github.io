---
layout:     post
title:      "搞懂堆排序"
subtitle:   "堆是啥？怎么用堆排序？"
date:       2018-08-19
author:     "Liuz2015"
header-img: "img/post-bg-unix-linux.jpg"
tags:
    - 算法
    - 排序
    - 堆排序
---

## 目录
- [简介](#简介)
- [堆的定义](#堆的定义)
- [堆的结构](#堆的结构)
- [堆的操作](#堆的操作)
- [堆排序](#堆排序)
- [优先级队列](#优先级队列)
- [扩展](#扩展)
- [总结](#总结)
- [参考资料](#参考资料)

## 简介

堆排序是许多排序算法中的一种，它的运行时间为O(nlgn)，与归并排序、快速排序一样快；同时，它是一种**原地排序算法**，原地排序算法是指在算法过程中需要使用的额外空间是固定的，相反的，归并排序就不是一种原地算法。此外，我们还需要直到，堆排序是一种**不稳定**的排序（排序的稳定性是指如果在排序的序列中，存在前后相同的两个元素的话，排序前 和排序后他们的相对位置不发生变化）。

堆排序使用一种叫做“堆”（二叉堆）的数据结构来管理算法执行中的信息，所以我们会先学习一下“堆”。当然，堆结构并不仅仅用在堆排序中，在优先队列以及其他算法中也有应有。

在“堆”的基础上，我们就可以实现堆排序算法了。

## 堆的定义

堆（二叉堆）在结构上可以看成一棵**完全二叉树**，同时它还满足二个特性：

- 父结点的键值总是大于或等于（小于或等于）子节点的键值。
- 每个结点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）。

当父结点的键值总是大于或等于任何一个子节点的键值时为**最大堆**，当父结点的键值总是小于或等于任何一个子节点的键值时为**最小堆**。

由于堆可以被看成是一棵树，结点在堆中的高度可以被定义为从本结点到叶子结点的最长简单下降路径上边的数目；定义堆的高度为树根的高度。我们将看到，堆结构上的一些基本操作的运行时间至多是与树的高度成正比，为O（lgn）。

## 堆的结构

堆一般都使用数组来进行存储，即使用数组来存储一棵完全二叉树。

在数组中，对下标为i的节点来说，它的父节点下标为i/2（向下取整），它的左孩子节点坐标为i\*2，它的右孩子节点坐标为i\*2+1（注意：数组从第一位开始使用）。

如图所示：

![堆的结构](/img\in-post\algorithm-heap-sort\heap-structure.jpg)

## 堆的操作

堆的操作主要分为插入和删除。我们使用大根堆进行说明。

我们先来看堆的插入：将新节点添加到数组的最后一位；由于父节点一定要比子节点大，我们需要进行自下而上的调整，对于这个新节点来说，我们可以将其与父节点进行比较，若大于父节点，则交换两者，直到父节点比该节点大，或者已经移动到根节点，这个操作操作我们可以称为**上浮**。

通过将节点一个个插入到堆中，就可以建立一个堆。

代码如下：

```cpp
void MaxHeapFixup(int a[], int i)  
{  
    for (int j = i / 2; (j >= 1 && i != 1)&&a[i] < a[j]; i = j, j = i / 2)  
        Swap(a[i], a[j]);  
}

void MaxHeapInsert(int a[], int n, int nNum)  
{  
    a[n] = nNum;  
    MinHeapFixup(a, n);  
}
```

堆的删除是指取出堆的根节点，我们的做法是：将数组的最后一个节点的值赋给根节点（数组的第一个节点），然后删除最后一个节点；同样得，进行刚才的操作后，我们需要进行自上而下的调整，将根节点与子节点中值最大的节点进行比较，若小于则交换位置，直到比子节点都大或者已经移动到最下一层，这个操作可以称为**下沉**。

代码如下：

```cpp
void MaxHeapFixdown(int a[], int i, int n)  
{  
    int j, temp;  
  
    temp = a[i];  
    j = 2 * i;  
    while (j <= n)  
    {  
        if (j + 1 < n && a[j + 1] < a[j]) //在左右孩子中找最小的  
            j++;  
  
        if (a[j] >= temp)  
            break;  
  
        a[i] = a[j]; //把较小的子结点往上移动,替换它的父结点  
        i = j;  
        j = 2 * i + 1;  
    }  
    a[i] = temp; 
}

void MaxHeapDelete(int a[], int n)  
{  
    Swap(a[1], a[n]);  
    MinHeapFixdown(a, 1, n);  
}  
```

## 堆排序

那么如何使用堆进行排序呢？我们现在开始对一个数组进行从小到大的排序：先使用数组里面的元素构建出一个最大堆，然后将堆顶元素一个一个取出（取出来的元素值一定是从大到小的），放到有序数列即可。

这个时候有同学可能会问了，那我是不是要新建一个数组去构建堆呢，这不就需要额外的线性空间了么？并不需要，我们使用原数组进行堆的构建即可。

假设数组A元素（从第一位开始使用）长度为n，一开始从A[1]到A[n]都是待排序区；现在我们将A[1]插入堆中，开始建堆，此时A[1]到A[1]是堆，而A[2]到A[n]是待排序区；我们再将A[2]插入堆中，那么A[1]到A[2]就是堆，A[3]到A[n]是待排序区；重复以上过程，直到A[1]到A[n]是堆，这时候我们就在原数组中构建了一个堆。

然后我们使用堆的删除操作，取出A[1]元素（堆的根节点），放到A[n]，这时候，堆的范围是A[1]到A[n-1]，而A[n]到A[n]是有序区；再进行堆的删除，取出A[1]（必然比上一个被删除的根节点小），放到A[n-1]，堆的范围变为A[1]到A[n-2]，有序区为A[n-1]到A[n]；重复以上过程，直到堆全部被删除，我们就得到了A[1]到A[n]的从小到大的有序数列。

```cpp
void BuildMaxHeap(int a[], int n)  
{  
    for (int i = 2; i <= n; i++)  
    {
        MaxHeapInsert(a, int i, int a[i]);
    }    
}  

void MaxHeapSort(int a[], int n)  
{  
    BuildMaxHeap(int a[], int n)
    for (int i = n; i > 1; i--)  
    {  
        MaxHeapDelete(a, 1, i);
    }  
}  
```

由于每次重新恢复堆的时间复杂度为O(logn)，共n - 1次重新恢复堆操作，再加上前面建立堆时n / 2次向下调整，每次调整时间复杂度也为O(logn)。二次操作时间相加还是O(nlogn)。故堆排序的时间复杂度为O(nlogn)。

## 优先级队列

然而实际上快速排序的表现比堆排序更好，不过的堆的数据结构还有很大用处。其中一个常见的应用就是**优先级队列**。

优先级队列（这里以最大优先级队列为例）支持的操作有以下几种：

- INSERT(S, x)：将x插入队列S。
- MAXIMUM(S)；返回队列S的最大值。
- EXTRACT-MAX(S)：删除并返回队列S的最大值。
- INCREASE-KEY(S, x, k):将队列S中s的值增加到k，注意k不能小于x的值。

在堆的基础上，我们可以很好的实现以上操作，在此不做赘述。

## 扩展

本文讨论的堆是二叉堆，但是堆的种类不止这一种，其他还有k叉堆，斐波那契堆等，感兴趣的可以去找资料深入研究哦~

## 参考资料
- 《算法导论》
- [堆排序_百度百科](https://baike.baidu.com/item/%E5%A0%86%E6%8E%92%E5%BA%8F/2840151?fr=aladdin#4_1)

